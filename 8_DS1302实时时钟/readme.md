# 8 DS1302实时时钟

 [toc]

注：笔记主要参考B站江科大自化协教学视频“[51单片机入门教程-2020版 程序全程纯手打 从零开始入门](https://www.bilibili.com/video/BV1Mb411e7re?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click)”。
***

## 8.1 芯片介绍：DS1302
RTC(Real Time Clock)实时时钟，是一种集成电路，通常称为时钟芯片。常见的时钟芯片有DS1302，是由美国DALLAS公司推出的具有涓细电流充电能力的低功耗实时时钟芯片。它可以对年、月、日、周、时、分、秒进行计时，且具有闰年补偿等多种功能。**本节的关键在于DS1302的时序。**



<div align=center>
<img src="https://raw.githubusercontent.com/jjejdhhd/Git_img2023/main/8051chip/DS1302%E5%AE%9E%E7%89%A9%E5%9B%BE.png" width=80%>
</div><div align=center>
图8-1 DS1302实物图
</div>

那为什么不使用单片机上的定时器来驱动实时时钟呢？
> 1. CPU内的定时器精度不高。
> 2. 使用定时器会占用CPU的内部资源。
> 3. 单片机定时器掉电不能继续工作。
>


<div align=center>
<img src="https://raw.githubusercontent.com/jjejdhhd/Git_img2023/main/8051chip/DS1302%E5%8E%9F%E7%90%86%E5%9B%BE.png" width=40%>
</div><div align=center>
图8-2 DS1302原理图
</div>

> 芯片引脚说明：
> CE：输入，芯片使能引脚。
> SCLK：输入，串行接口时钟。
> I/O：双向，输入输出的串行数据，SCLK上升沿触发。

基本逻辑是利用下面的寄存器地址说明（图8-4），写入的时候按需更改相应的秒数，读出的时候则依次进行读出。前八位是读写的选择和读写的地址，后八位才是具体要进行读写的数据，且**先传输低位**。前八位也被称为<u>命令字，最高位写保护，控制能否串行写入（1/0），但一直可以读；R/C选择是RAM数据/时钟数据（1/0）；A4~A0则为5位寄存器地址；R/W位则控制读写（1/0）。</u>下面则给出了DS1602的读/写传输时序、寄存器操作地址：
<div align=center>
<img src="https://raw.githubusercontent.com/jjejdhhd/Git_img2023/main/8051chip/DS1602%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BA%8F.png" width=60%>
</div><div align=center>
图8-3 DS1302数据传输时序
</div>

<div align=center>
<img src="https://raw.githubusercontent.com/jjejdhhd/Git_img2023/main/8051chip/DS1602%E5%AF%84%E5%AD%98%E5%99%A8%E5%9C%B0%E5%9D%80.png" width=70%>
</div><div align=center>
图8-4 RTC相关寄存器

注：左侧的八位是直接给出了**命令字**。
</div>

值得注意的是，上面寄存器所显示的数据，都采用BCD码（Binary Coded Decimal）进行编码：
> - 用4位二进制数来表示1位十进制数
>   例：0001 0011表示13，1000 0101表示85，0001 1010不合法
>   在十六进制中的体现：0x13表示13，0x85表示85，0x1A不合法
> - BCD码转十进制：DEC=BCD/16\*10+BCD%16; （2位BCD）
>   十进制转BCD码：BCD=DEC/10\*16+DEC%10; （2位BCD）
> - CH位：时停控制位，写入此位为高电平，则时钟暂停。
> - 12/24位：设置12小时/24小时模式位。12小时模式，BIT5表示AM/PM，BIT4表示十位；24小时模式，[BIT5,BIT4]表示十位。
> - 关于星期：注意这个星期不是实际的星期，而是“处理日”，所以需要用户指定初始的星期偏置。


## 8.2 实验：DS1302时钟显示
需求：在LCD显示屏第一行显示日期“年-月-日”，第二行显示时间“时-分-秒”，24小时制。

<div align=center>
<img src="https://raw.githubusercontent.com/jjejdhhd/Git_img2023/main/8051chip/%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB-%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F.png" width=20%>
</div><div align=center>
图8-5 “实时时钟”代码调用关系
</div>

代码展示：
**- main.c**

**- DS1302.h**

**- DS1302.c**

**- LCD1602.h**：增加了星期显示函数“LCD1602_ShowDay”，可以方便的将数字转换成三位的英文缩写。

**- LCD1602.c**

编程感想：
> 1. 注意 **单片机复位后引脚默认为1**，所以DS1302的控制引脚都需要初始化。
> 2. 若读出的数字不动，则有可能是芯片处于写保护状态；若读出的数字乱跳，需要注意读状态结束后，需要手动将IO线归零。

## 8.3 实验：可调时钟
需求：在上面8.2实验的基础上，增加可调整日期和时间的功能。
> 1. 按键K1用于切换显示模式/调节模式。
> 2. 按键K2用于切换所需要调节的位（年/月/日/时/分/秒），切换到哪个哪个就闪烁。
> 3. 按键K3增加计数，按键K4减少计数，秒只能归到0或30秒。这个地方注意不能违背闰月28天等常识。

上一节实验没有考虑星期显示的问题，本节首先改进。进过反复的测试，发现表示“星期”的字节有这样奇怪的属性：每次芯片掉电重启后自动归1；但如果不掉电，则会在23:59:59后随时间一起加1，但是**芯片本身不会根据日期自动生成“星期”**。所以每次对日期进行重写后，也要对“星期”进行重写使其变成1，于是芯片给出的“星期”的物理意义就变成了 **“从最近一次设定时间到现在经历的天数（星期表示）”**，即“处理日”。所以，还需要再添加一个存储“星期偏置”的常量，将其与“处理日”相结合便可以得到正确的星期。

另外本节实验，使用软件演示来完成按键检测；使用定时器延时来完成修改时间参数时的闪烁状态。

<div align=center>
<img src="https://raw.githubusercontent.com/jjejdhhd/Git_img2023/main/8051chip/%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8-%E5%8F%AF%E8%B0%83%E6%97%B6%E9%92%9F.png" width=20%>
</div><div align=center>
图8-6 “可调时钟”代码调用关系
</div>

**- mian.c**

**- DS1302.h**

**- DS1302.c**

**- LCD1602.h**

**- LCD1602.c**

**- PushKey.h**

**- Timer0.h**

**- Delay.h**

编程感想：
> 1. 天坑：每次复位后，“星期”的显示都归成1，意思为“处理日”，不是实际的星期。
> 2. 缺陷：由于按键检测使用 ```while``` 循环等待按键松开，所以按键不松手的时候时钟显示会“暂停”（但是不影响DS1302继续计数），只有松手后，画面才会继续显示。后续会使用定时器来检测按键的上升沿，可以改善这个问题。
